#include"Time.h"

#include<iostream>

void func()
{

}
void func(int i)
{

}
void func(double i)
{

}
int main()
{
	//一：重载运算符
	// 可以重载的运算符
	//+  -  *  /  %  ^  &  |  ~  !  =  <  >  +=  -=  *=  /=  %=  ^=  &=  |=  <<  >>  <<=  >>=  
	//==  !=  <=  >=  &&  ||  ++  --  ,  ->*  ->  ()  []  new  new[]  delete  delete[]
	//上述运算符中，[]是下标运算符，()是函数调用运算符。自增自减运算符的前置和后置形式都可以重载。
	//长度运算符sizeof、条件运算符: ?、成员选择符.和域解析运算符::不能被重载。


	//int a = 4, b = 5;
	//if (a == b)
	//{
	//	//...
	//}
	/*TimeClass myTime;
	TimeClass myTime1;*/
	//if (myTime == myTime1)
	//{
	//	//...
	//}


	//2个对象的比较，我们需要使用"重载==运算符"
	//重载，我们要写一个成员函数，这个成员函数名 "operator==",这个成员函数体里边我们就要写一些比较逻辑。
	//
	//重载运算符，本质上是一个函数。整个成员函数的正式名字：operator关键字 接 运算符
	//会有返回类型和参数列表
	//有一些运算符，如果我们不自己写该运算符的重载，那么系统会自动给我们生成一个。
	//比如赋值运算符的重载


	/*Time mytime1;
	Time mytime2;
	mytime1 = mytime2;*/


	//拷贝赋值运算符
	//Time myTime;  //调用Time::Time()构造函数
	//Time myTime2 = myTime; //调用Time::Time(const Time&tmptime, int a)拷贝构造函数
	//Time myTime5 = {myTime};//调用Time::Time(const Time&tmptime, int a)拷贝构造函数

	//Time myTime6;//调用Time::Time()构造函数


	//myTime6 = myTime5;//赋值运算符,既没有调用构造函数，也没有调用拷贝构造函数
	                //系统会调用一个拷贝赋值运算符
	//我们可以自己重载赋值运算符。如果我们自己不重载，编译器也会为我们自动生成一个。
	//编译器生成的赋值运算符比较粗糙，一般就是将非static成员赋值给赋值运算符左侧的对象的对应成员中去
	//如果你这个成员是个类对象，可能会调用这个类的拷贝赋值运算符
	//为了精确控制Time类的赋值动作，我们往往会自己来实现重载赋值运算符
	//重载赋值运算符：有返回类型和参数列表，这里的参数表示运算符的运算对象。比如myTime5就是运算对象

	//myTime6就是this对象。 myTime5就是operator=里边的参数

	//析构函数：相对于构造函数。
	//对象在销毁时会自动调用析构函数
	//如果我们自己不写一个析构函数，编译器也会生成一个默认的析构函数
	//默认析构函数的函数体为空{}表示默认析构函数没干什么有意义的事
	//构造函数里new，delete
	//析构函数也是类的成员函数，它的名字是由~接类名构成，没有返回值，不接受任何参数，不能被重载，所以给定的类，只有唯一一个析构函数

	//函数重载：就是系统允许函数名字相同，但是这些同名函数的参数个数或者参数类型不同，系统允许这些同名函数同时存在
	//当我们调用这些函数的时候，系统根据调用这个函数时我们所提供的参数类型，参数个数，就能区别出来你到底想调用哪个函数

	//构造函数的成员初始化：干了2件事，函数体之前和函数体之中
	//析构函数的成员销毁：干了2件事，函数体，函数体之后

	//成员变量的初始化和销毁：先定义的先初始化，销毁时，先定义的后销毁
	//new 和 delete
	
	
	//new对象和delete对象 new对象时候，系统调用了Time类的构造函数
	Time *pmytime5 = new Time;//调用不带参数的构造函数
	Time *pmytime6 = new Time();//调用不带参数的构造函数

	delete pmytime5;
	delete pmytime6;
	//你什么时候delete，系统什么时候去调用类Time的析构函数




	return 0;
}

